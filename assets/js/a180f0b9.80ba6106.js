(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{84:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return p})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return b}));var a=t(3),s=t(8),i=(t(0),t(96)),o=t(101),l=t(100),r={title:"Working With Field Maps"},p={unversionedId:"recipes/field-maps",id:"recipes/field-maps",isDocsHomePage:!1,title:"Working With Field Maps",description:"Field Maps are one of the most essential pieces of GraphQL-Utils. They are a parsed version of the GraphQL AST simplified to take fragments into account as well as remove the extra data we aren't interested in.",source:"@site/docs/recipes/field-maps.mdx",slug:"/recipes/field-maps",permalink:"/graphql-utils/docs/recipes/field-maps",editUrl:"https://github.com/jenyus-org/graphql-utils/edit/master/docs/docs/recipes/field-maps.mdx",version:"current",sidebar:"docsSidebar",previous:{title:"Getting Started",permalink:"/graphql-utils/docs/getting-started"},next:{title:"Checking For Fields To Do Conditional JOINs",permalink:"/graphql-utils/docs/recipes/checking-for-fields"}},c=[{value:"Resolving A Field Map",id:"resolving-a-field-map",children:[{value:"Deep",id:"deep",children:[]},{value:"Flat",id:"flat",children:[]},{value:"Under A Specified Parent",id:"under-a-specified-parent",children:[]}]},{value:"Usage with KnexJS",id:"usage-with-knexjs",children:[]},{value:"Usage with MikroORM",id:"usage-with-mikroorm",children:[]},{value:"Playground",id:"playground",children:[]}],d={toc:c};function b(e){var n=e.components,t=Object(s.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},d,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Field Maps")," are one of the most essential pieces of ",Object(i.b)("strong",{parentName:"p"},"GraphQL-Utils"),". They are a parsed version of the GraphQL AST simplified to take fragments into account as well as remove the extra data we aren't interested in."),Object(i.b)("p",null,"You can read more about the ",Object(i.b)("inlineCode",{parentName:"p"},"FieldMap")," interface ",Object(i.b)("a",{parentName:"p",href:"/graphql-utils/docs/reference/interfaces#fieldmap"},"here"),"."),Object(i.b)("p",null,"In order to retrieve the field map we can use the ",Object(i.b)("inlineCode",{parentName:"p"},"resolveFieldMap()")," helper, which takes ",Object(i.b)("inlineCode",{parentName:"p"},"info")," as its only required argument, and we may additionally specify whether a deep field map should be parsed, so we can check nested data and calculate the cost of a query, or just a single layer for example to help us optimize our SQL ",Object(i.b)("inlineCode",{parentName:"p"},"SELECT")," and ",Object(i.b)("inlineCode",{parentName:"p"},"JOIN")," queries."),Object(i.b)("h2",{id:"resolving-a-field-map"},"Resolving A Field Map"),Object(i.b)("p",null,"In order to resolve a field map, all we need to do is use the ",Object(i.b)("inlineCode",{parentName:"p"},"info")," argument passed to our GraphQL resolvers, and retrieve the field map using the ",Object(i.b)("inlineCode",{parentName:"p"},"resolveFieldMap()")," helper, we can pass various options to adjust the output."),Object(i.b)("p",null,"Let's take a look at an example query:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-graphql"},"{\n  posts {\n    id\n    title\n    body\n    author {\n      id\n      username\n      firstName\n      lastName\n    }\n  }\n}\n")),Object(i.b)("h3",{id:"deep"},"Deep"),Object(i.b)("p",null,"If we want the deep field map without any additional configuration, all we need to do is call ",Object(i.b)("inlineCode",{parentName:"p"},"resolveFieldMap()")," with our ",Object(i.b)("inlineCode",{parentName:"p"},"info")," object:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'import { resolveFieldMap } from "@jenyus-org/graphql-utils";\n\nconst resolvers = {\n  Query: {\n    posts(_, __, ___, info) {\n      const fieldMap = resolveFieldMap(info);\n      console.log(fieldMap);\n    },\n  },\n};\n')),Object(i.b)("p",null,"This will output the following field map:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},"{\n  posts: {\n    id: {},\n    title: {},\n    body: {},\n    author: {\n      id: {},\n      username: {},\n      firstName: {},\n      lastName: {},\n    },\n  }\n}\n")),Object(i.b)("p",null,"Now, if we want to know which columns to ",Object(i.b)("inlineCode",{parentName:"p"},"SELECT")," from our database, we can use a simple filter to only retrieve those fields without subselections, and then print those keys:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},"const fields = Object.entries(fieldMap.posts)\n  .filter(([key, values]) => Object.keys(values).length)\n  .map(([key, _]) => key);\nconsole.log(fields);\n")),Object(i.b)("p",null,"Our output will be as follows:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-json"},'["id", "title", "body"]\n')),Object(i.b)("h3",{id:"flat"},"Flat"),Object(i.b)("p",null,"We can also resolve a flat field map, if we only want to use it to e.g. optimize SQL queries. The flat field map will be able to tell us which columns we need to ",Object(i.b)("inlineCode",{parentName:"p"},"SELECT"),", which can be used in combination with a query builder like KnexJS or ORMs like MikroORM to make more efficient calls to our database."),Object(i.b)("p",null,"For this we simply pass ",Object(i.b)("inlineCode",{parentName:"p"},"false")," to the second argument of ",Object(i.b)("inlineCode",{parentName:"p"},"resolveFieldMap()"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'import { resolveFieldMap } from "@jenyus-org/graphql-utils";\n\nconst resolvers = {\n  Query: {\n    posts(_, __, ___, info) {\n      const fieldMap = resolveFieldMap(info, false);\n      console.log(fieldMap);\n    },\n  },\n};\n')),Object(i.b)("p",null,"This will output the following field map:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},"{\n  posts: {\n    id: {},\n    title: {},\n    body: {},\n    author: {},\n  }\n}\n")),Object(i.b)("p",null,"Then, we could use ",Object(i.b)("inlineCode",{parentName:"p"},"Object.keys()")," to get a list of all the selected fields:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},"const fields = Object.keys(fieldMap.posts);\nconsole.log(fields);\n")),Object(i.b)("p",null,"Our output will be as follows:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-json"},'["id", "title", "body", "author"]\n')),Object(i.b)("p",null,"Since ",Object(i.b)("inlineCode",{parentName:"p"},"author")," isn't a field we can just ",Object(i.b)("inlineCode",{parentName:"p"},"SELECT")," from our database, it might make more sense to use the deep field map to filter out fields with subselections as we showed above."),Object(i.b)("h3",{id:"under-a-specified-parent"},"Under A Specified Parent"),Object(i.b)("p",null,"If we only want to retrieve the field map under a specified parent, we can use dot-notation or an array of strings to specify this parent. This can be useful for queries that are computed instead of direct entrypoints to database tables, and we need to get all the fields requested for each entity."),Object(i.b)("p",null,"Let's change up our query a bit:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-graphql"},"{\n  postsOverview {\n    topPosts {\n      id\n      title\n      body\n      author {\n        id\n        username\n        firstName\n        lastName\n      }\n    }\n    risingPosts {\n      id\n      title\n      body\n      author {\n        id\n        username\n        firstName\n        lastName\n      }\n    }\n  }\n}\n")),Object(i.b)("p",null,"Now we can specify the parent under which we want to get our field map from with either of the two syntaxes:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"postsOverview.topPosts"')),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'["postsOverview", "topPosts"]'))),Object(i.b)("p",null,"The rest of how ",Object(i.b)("inlineCode",{parentName:"p"},"resolveFieldMap()")," works is identical to the previous examples, we just need to make sure to specify ",Object(i.b)("inlineCode",{parentName:"p"},"deep")," in the arguments:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'import { resolveFieldMap } from "@jenyus-org/graphql-utils";\n\nconst resolvers = {\n  Query: {\n    postsOverview(_, __, ___, info) {\n      const fieldMap = resolveFieldMap(info, true, "postsOverview.topPosts");\n      console.log(fieldMap);\n    },\n  },\n};\n')),Object(i.b)("p",null,"This will output the following field map:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},"{\n  topPosts: {\n    id: {},\n    title: {},\n    body: {},\n    author: {\n      id: {},\n      username: {},\n      firstName: {},\n      lastName: {},\n    },\n  }\n}\n")),Object(i.b)("h2",{id:"usage-with-knexjs"},"Usage with KnexJS"),Object(i.b)("p",null,"Using deep field maps, we can check for fields that don't have any subselections, and assume they are database columns. Using KnexJS we can build dynamic SQL ",Object(i.b)("inlineCode",{parentName:"p"},"SELECT")," statements this way:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'import { resolveFieldMap } from "@jenyus-org/graphql-utils";\n\nconst resolvers = {\n  Query: {\n    posts(_, { db }, ___, info) {\n      const fieldMap = resolveFieldMap(info);\n      const columns = Object.entries(fieldMap.posts)\n        // check if field doesn\'t have subselections\n        .filter(([_, selections]) => !Object.keys(selections).length)\n        .map(([key]) => key);\n\n      return db.select(...columns).from("posts");\n    },\n  },\n};\n')),Object(i.b)("h2",{id:"usage-with-mikroorm"},"Usage with MikroORM"),Object(i.b)("p",null,"Similar to how we did dynamic field selections with KnexJS, we can use MikroORM's entity repository ",Object(i.b)("inlineCode",{parentName:"p"},"fields")," and ",Object(i.b)("inlineCode",{parentName:"p"},"populate")," options to not only dynamically ",Object(i.b)("inlineCode",{parentName:"p"},"SELECT")," specific columns, but also pre-populated relational fields using SQL ",Object(i.b)("inlineCode",{parentName:"p"},"JOIN"),"s if we assume fields with subselections are relations in our MikroORM entities:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'import { resolveFieldMap } from "@jenyus-org/graphql-utils";\n\nconst resolvers = {\n  Query: {\n    posts(_, { postsRepository }, ___, info) {\n      const fieldMap = resolveFieldMap(info);\n\n      const fields = Object.entries(fieldMap.posts)\n        // check if field doesn\'t have subselections\n        .filter(([_, selections]) => !Object.keys(selections).length)\n        .map(([key]) => key);\n\n      const relations = Object.entries(fieldMap.posts)\n        // check if field has subselections\n        .filter(([_, selections]) => !!Object.keys(selections).length)\n        .map(([key]) => key);\n\n      return postsRepository.find({}, { populate: relations, fields });\n    },\n  },\n  Post: {\n    // fallback field resolver\n    author(post, { usersRepository }) {\n      if (post.author) {\n        // author was already fetched in query with KnexJS\n        return post.author;\n      }\n\n      // we still need to fetch the author from the DB\n      return usersRepository.findOne({ id: post.authorId });\n    },\n  },\n};\n')),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",{parentName:"div",className:"admonition-heading"},Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",{parentName:"h5",className:"admonition-icon"},Object(i.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(i.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),Object(i.b)("div",{parentName:"div",className:"admonition-content"},Object(i.b)("p",{parentName:"div"},"This is the barebones method of using field maps to get columns and relations to ",Object(i.b)("inlineCode",{parentName:"p"},"SELECT")," and populate. See ",Object(i.b)("a",{parentName:"p",href:"/graphql-utils/docs/recipes/resolving-selections"},"Resolving Selections For Use With ORMs")," for a more declarative approach."))),Object(i.b)("h2",{id:"playground"},"Playground"),Object(i.b)(o.a,{func:function(e){return Object(l.resolveFieldMap)(e)},graphql:"\n  {\n    posts {\n      id\n      title\n      body\n      author {\n        id\n        username\n        firstName\n        lastName\n      }\n    }\n  }\n  ",code:'\n  import { resolveFieldMap } from "@jenyus-org/graphql-utils";\n  \n\n  const resolvers = {\n    Query: {\n      posts(_, __, ___, info) {\n        const fieldMap = resolveFieldMap(info);\n        console.log(fieldMap);\n      },\n    },\n  };\n  ',mdxType:"Sandbox"}))}b.isMDXComponent=!0}}]);